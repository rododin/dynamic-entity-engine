#labels DynamicEntityEngine,ru
= Dynamic Entity Engine – Обзор =

== Мотивация ==

Знакомы ли Вы с игрой «Герои Меча и Магии» или с «Цивилизацией»? Или с любой другой игрой с множеством различных юнитов, наподобие Драконов, Рыцарей, Лучников, или, может быть, Танков, Сверхзвуковых Истребителей и Ракетных Крейсеров? Или может быть Вы разрабатываете бизнес-приложение с десятками различных бизнес-сущностей, с которыми Ваша бизнес-логика должна работать?

Если Вы разрабатываете что-то наподобие этого, как бы Вы поступили?
Будете ли Вы создавать десятки или сотни классов (по одному на каждую сущность) с десятками get/set-методов (по паре на каждое свойство) внутри? Конечно же, Вы – один из опытнейших объектно-ориентированных разработчиков и Вы построите прекрасно-продуманную иерархию сущностей (или игровых юнитов). И если Ваши сущности должны сохраняться долговременно (в БД, например), то Вы пропишите их отображения на реляционные таблицы с помощью JPA-аннотаций. После чего Вы напишете тонны бизнес-логики (десятки сессионных бинов), чтобы как-то управлять и обрабатывать эти плоские сущности – сущности, просто состоящие из наборов свойств, задаваемых парами get/set-методов.

А что бы Вы сделали, если Вашей бизнес-логике требуется перехватывать события наподобие propertyChanged или propertyAccessed? Например, Вы имеете 50-60 различных сущностей, содержащих в среднем по 10 свойств каждая. Но лишь в небольшом ряде случаев Вам требуется перехватывать события типа propertyChanged или entitySaved. Станете ли Вы добавлять поддержку слушателя событий в каждый get/set-метод, где это потребуется? Или Вы добавите поддержку слушателей во все get/set-методы, т.к. Вы не знаете заранее, где она может потребоваться?

А давайте снова вернёмся к объектно-ориентированной иерархии… К примеру, все Ваши сущности имеют свойство id, выступающее в роли первичного ключа. В большинстве случаев этот id – целое число, но в редких исключениях это строка. Многие Ваши сущности имеют свойство name, например User, Client или Organization. User и Client являются людьми, поэтому их общие свойства (name, surname, birthDate и taxNumber) Вы можете задать в общем базовом классе Person. Однако свойство name должно перейти в ещё более абстрактный класс (назовём его NamedEntity), поскольку Organization также имеет имя. Поле taxNumber должно перейти в класс Client, поскольку оно касается только клиентов и никак не касается, например, User-а. Но Organization также может играть роль клиента, поэтому Client не есть Person. В такой ситуации Client представляет просто абстрактного клиента, который расширяется до конкретных ClientPerson и ClientOrganization. Соответсвенно, ClientPerson должен наследовать два класса: Person и Client. Аналогично ClientOrganization – два класса: Organization и Client. Окончательная иерархия выглядит как показано на рисунке 1.
В Java, однако, Вы не имеете множественного наследования, а интерфейсы не работают, т.к. Вам необходимо прописать JPA-аннотации к свойствам. Но даже если бы интерфейсы работали, Вам было бы необходимо повторять код, реализующий одинаковые свойства, или, как минимум, Вам  пришлось бы агрегировать единственную реализацию многократно, при этом код доступа к агрегациям опять таки должен повторяться. Иными словами, многократная агрегация является так же повторением кода.